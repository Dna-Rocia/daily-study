###状态模式(State)：
状态这个词汇我们并不陌生，在日常生活中，不同时间就有不同的状态，早上起来精神饱满，中文想睡觉，下午又渐渐恢复，晚上可能精神更旺也可能耗费体力只想睡觉，这一天中就对应着不同的状态。或者对软件开发人员更形象的描述可能是UML的状态图（即用于描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应）。
其实相对来说，就是一种状态的变化，而状态模式主要解决的问题就是当控制一个对象状态转换的条件表达式过于复杂时的情况。即把状态的判断逻辑转移到标识不同状态的一系列类当中。
　　

状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
####举例
1. context建立一个用于维护当前状态
2. State为抽象状态角色，定义一个接口以封装与Context的一个特定接口状态相关的行为
3. ConcreteState是具体状态角色，每一个子类实现一个与Context的一个状态相关的行为。

如果不用状态模式实现的话，常用的方法是在每个方法中使用switch语句来判断当前状态进行处理，而使用状态模式，通过各个子类来实现，避免了switch语句的判断，使得代码看起来不是那么的冗杂。
那么结合状态模式的特点，如果现在要增加两个状态即通电状态和断点状态呢？
其实很简单，只需增加两个子类，并在原有类上增加而不是去修改，符合开闭原则；而这里我们的状态都是单独的类，只有与这个状态有关的因素修改了，这个类才修改，符合迪米特法则。




###享元模式(Flyweight)
面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。
在享元模式中可以共享的相同内容称为 内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为 外部状态(Extrinsic State)，其中外部状态和内部状态是相互独立的，外部状态的变化不会引起内部状态的变化。由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。

享元模式（Flyweight）在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)，运用共享技术有效地支持大量细粒度的对象。
1. 模式所涉及的角色
- Flyweight： 享元接口，通过这个接口传入外部状态并作用于外部状态；
- ConcreteFlyweight： 具体的享元实现对象，必须是可共享的，需要封装享元对象的内部状态；
- UnsharedConcreteFlyweight： 非共享的享元实现对象，并不是所有的享元对象都可以共享，非共享的享元对象通常是享元对象的组合对象；
- FlyweightFactory： 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口；

