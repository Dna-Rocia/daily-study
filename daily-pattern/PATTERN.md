### 状态模式(State)：

状态这个词汇我们并不陌生，在日常生活中，不同时间就有不同的状态，早上起来精神饱满，中文想睡觉，下午又渐渐恢复，晚上可能精神更旺也可能耗费体力只想睡觉，这一天中就对应着不同的状态。或者对软件开发人员更形象的描述可能是UML的状态图（即用于描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应）。
其实相对来说，就是一种状态的变化，而状态模式主要解决的问题就是当控制一个对象状态转换的条件表达式过于复杂时的情况。即把状态的判断逻辑转移到标识不同状态的一系列类当中。

状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

- 举例

1. context建立一个用于维护当前状态
2. State为抽象状态角色，定义一个接口以封装与Context的一个特定接口状态相关的行为
3. ConcreteState是具体状态角色，每一个子类实现一个与Context的一个状态相关的行为。

如果不用状态模式实现的话，常用的方法是在每个方法中使用switch语句来判断当前状态进行处理，而使用状态模式，通过各个子类来实现，避免了switch语句的判断，使得代码看起来不是那么的冗杂。
那么结合状态模式的特点，如果现在要增加两个状态即通电状态和断点状态呢？ 其实很简单，只需增加两个子类，并在原有类上增加而不是去修改，符合开闭原则；而这里我们的状态都是单独的类，只有与这个状态有关的因素修改了，这个类才修改，符合迪米特法则。

### 享元模式(Flyweight)

面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。 在享元模式中可以共享的相同内容称为
内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为 外部状态(Extrinsic State)
，其中外部状态和内部状态是相互独立的，外部状态的变化不会引起内部状态的变化。由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。

享元模式（Flyweight）在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)，运用共享技术有效地支持大量细粒度的对象。

1. 模式所涉及的角色

- Flyweight： 享元接口，通过这个接口传入外部状态并作用于外部状态；
- ConcreteFlyweight： 具体的享元实现对象，必须是可共享的，需要封装享元对象的内部状态；
- UnsharedConcreteFlyweight： 非共享的享元实现对象，并不是所有的享元对象都可以共享，非共享的享元对象通常是享元对象的组合对象；
- FlyweightFactory： 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口；

### 装饰器模式(Decorator)

动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)
，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。

1 . 结构模式

- 角色： Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类

2 . 容易混淆的概念
> 一般有两种方式可以实现给一个类或对象增加行为：
>- 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
>- 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)

综上述，与继承关系相比，<u>关联关系的主要优势在于不会破坏类的封装性</u>，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。 在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了<u>
软件维护阶段，由于关联关系使系统具有较好的松耦合性</u>，因此使得系统更加容易维护。 当然，关联关系的缺点是比继承关系要创建更多的对象。
<u>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</u>

### 适配器模式（Adapter）

将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为<u>类结构型模式</u>，也可以作为<u>对象结构型模式</u>。















